<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Votazione Online | Faker</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #6f42c1;
            --primary-light: #8e67d5;
            --accent: #ffc107;
            --accent-dark: #e5ac00;
            --bg: #f8f9fa;
            --white: #ffffff;
            --text: #2d3436;
            --danger: #ff4757;
            --success: #04AA6D;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Outfit', sans-serif;
            background-color: var(--primary);
            background-image: linear-gradient(135deg, #6f42c1 0%, #4834d4 100%);
            color: var(--white);
            min-height: 100dvh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1.5rem;
        }

        .container {
            text-align: center;
            width: 100%;
            max-width: 500px;
            background: rgba(255, 255, 255, 0.1);
            padding: 2rem;
            border-radius: 40px;
            backdrop-filter: blur(15px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: zoomIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) both;
        }

        h1 {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            line-height: 1.4;
            font-weight: 400;
        }

        #dom {
            display: block;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
        }

        .voting-sub {
            font-size: 1.1rem;
            letter-spacing: 2px;
            opacity: 0.8;
            display: block;
            margin-top: 1rem;
        }

        .button-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 1.5rem;
        }

        .rounded-button {
            padding: 1.1rem 1rem;
            border: none;
            border-radius: 20px;
            background-color: var(--white);
            color: var(--primary);
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            width: 100%;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }

        .rounded-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
        }

        .rounded-button:disabled {
            opacity: 0.9;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            background-color: #f0f0f0;
            color: #888;
        }

        .rounded-button.voted:disabled {
            background-color: var(--success);
            color: white;
            opacity: 1;
        }

        .rounded-button.voted {
            background-color: var(--success);
            color: white;
            border: 2px solid #038a57;
        }

        .vote-count {
            background-color: var(--primary);
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 50px;
            font-size: 0.9rem;
            min-width: 30px;
            text-align: center;
        }

        .you-badge {
            font-size: 0.7rem;
            background: var(--accent);
            color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
            vertical-align: middle;
        }

        .waiting-status {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.95rem;
            opacity: 0.9;
        }

        .waiting-animation {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        @keyframes zoomIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .player-btn-wrapper {
            animation: slideIn 0.4s ease both;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(15px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            background: var(--white);
            color: var(--text);
            border-radius: 30px;
            padding: 2rem;
            text-align: center;
            width: 90%;
            max-width: 380px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            animation: slideUp 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .modal-icon {
            font-size: 4rem;
            margin-bottom: 0.5rem;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: var(--primary);
        }

        .modal-message {
            font-size: 1.1rem;
            opacity: 0.8;
            margin-bottom: 1.5rem;
            line-height: 1.4;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .modal-btn {
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s;
            flex: 1;
        }

        .btn-confirm {
            background: var(--success);
            color: white;
        }

        .btn-cancel {
            background: #e0e0e0;
            color: #555;
        }

        .btn-continue {
            background: var(--primary);
            color: white;
            width: 100%;
        }

        .modal-btn:hover {
            transform: translateY(-2px);
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(50px) scale(0.9);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>
            <span id="dom">CARICAMENTO...</span>
            <span class="voting-sub">üïµÔ∏è VOTA CHI ELIMINARE</span>
        </h1>

        <div id="button-container" class="button-list"></div>

        <div id="waitingStatus" class="waiting-status"></div>
    </div>

    <!-- Modal Risultato/Eliminazione -->
    <div id="resultModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-icon" id="modalIcon">üëª</div>
            <div class="modal-title" id="modalTitle">Risultato</div>
            <div class="modal-message" id="modalMessage">Messaggio</div>
            <button class="modal-btn btn-continue" onclick="closeModalAndContinue()">CONTINUA</button>
        </div>
    </div>

    <!-- Modal Conferma Voto -->
    <div id="confirmVoteModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-icon">ü§î</div>
            <div class="modal-title">Conferma Voto</div>
            <div class="modal-message">Vuoi davvero eliminare <strong id="confirmVoteName"></strong>?</div>
            <div class="modal-actions">
                <button class="modal-btn btn-cancel" onclick="closeConfirmModal()">Annulla</button>
                <button class="modal-btn btn-confirm" id="confirmVoteBtn">CONFERMA</button>
            </div>
        </div>
    </div>

    <script>
        // CONFIGURAZIONE SUPABASE
        const SUPABASE_URL = 'https://iiwcqemmtdmzzgiytlqr.supabase.co';
        const SUPABASE_ANON_KEY = 'sb_publishable_pBR3LS6E0PEXe7cbSRuu_g_JOGA9rY-';

        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        const roomId = sessionStorage.getItem('roomId');
        const playerName = sessionStorage.getItem('playerName');
        const isHost = sessionStorage.getItem('isHost') === 'true';

        if (!roomId || !playerName) {
            window.location.href = 'index.html';
        }

        let allPlayers = [];
        let activePlayers = []; // Solo giocatori non eliminati
        let votes = {};
        let myVote = null;
        let currentRoom = null;
        let amIEliminated = false;
        let pendingRedirect = null;
        let myPlayer = null;

        // Funzioni per il modal popup
        function showResultModal(icon, title, message) {
            document.getElementById('modalIcon').textContent = icon;
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;
            document.getElementById('resultModal').style.display = 'flex';
        }

        function closeModalAndContinue() {
            document.getElementById('resultModal').style.display = 'none';
            if (pendingRedirect) {
                window.location.href = pendingRedirect;
            }
        }

        function closeConfirmModal() {
            document.getElementById('confirmVoteModal').style.display = 'none';
        }

        async function initVoting() {
            const domanda = sessionStorage.getItem('onlineDomanda') || 'Indica qualcuno...';
            document.getElementById('dom').textContent = domanda;

            const { data: playersData } = await supabaseClient
                .from('players')
                .select('*')
                .eq('room_id', roomId)
                .order('created_at', { ascending: true });

            allPlayers = playersData;

            // Fix ReferenceError: define myPlayer here
            myPlayer = allPlayers.find(p => p.name === playerName);

            const { data: room } = await supabaseClient
                .from('rooms')
                .select('*')
                .eq('id', roomId)
                .single();

            currentRoom = room;

            const eliminatedPlayers = currentRoom.eliminated_players || [];
            activePlayers = allPlayers.filter(p => !eliminatedPlayers.includes(p.name));
            amIEliminated = eliminatedPlayers.includes(playerName);

            if (currentRoom.status === 'finished') {
                if (currentRoom.winner === 'players') {
                    sessionStorage.setItem('gameResult', 'players_win');
                } else {
                    sessionStorage.setItem('gameResult', 'faker_wins');
                }
                sessionStorage.setItem('faker_name', currentRoom.faker_name || '');
                window.location.href = 'online_end.html';
                return;
            } else if (currentRoom.status === 'playing') {
                sessionStorage.removeItem('onlineDomanda');
                window.location.href = 'online_game1.html';
                return;
            }

            if (amIEliminated) {
                showEliminatedState();
            }

            // SELF-CLEANING: Resetto il mio is_ready (proveniente dal game 1)
            if (myPlayer) {
                await supabaseClient
                    .from('players')
                    .update({ is_ready: false })
                    .eq('id', myPlayer.id);
            }

            // Carica voti iniziali
            const { data: votedPlayers } = await supabaseClient
                .from('players')
                .select('name, vote_target')
                .eq('room_id', roomId);

            votes = {};
            votedPlayers.forEach(p => {
                if (p.vote_target) votes[p.name] = p.vote_target;
            });

            if (votes[playerName]) {
                myVote = votes[playerName];
            }

            renderButtons();
            subscribeToVotes();
            checkAllVoted(allPlayers);
        }

        function showEliminatedState() {
            const domanda = sessionStorage.getItem('onlineDomanda') || 'Votazione';
            document.querySelector('h1').innerHTML = `<span id="dom">${domanda}</span><span class="voting-sub" style="color:white;opacity:0.8">üëª ${playerName} (OSSERVATORE)</span>`;
            document.getElementById('waitingStatus').innerHTML =
                '<div class="waiting-animation">Guarda le votazioni in tempo reale...</div>';
            updateWaitingStatus();
        }

        function renderButtons() {
            const buttonContainer = document.getElementById('button-container');
            buttonContainer.innerHTML = '';

            activePlayers.forEach((player, index) => {
                const buttonWrapper = document.createElement('div');
                buttonWrapper.classList.add('player-btn-wrapper');
                buttonWrapper.style.animationDelay = (index * 0.05) + 's';

                const button = document.createElement('button');
                button.classList.add('rounded-button');

                const voteCount = Object.values(votes).filter(v => v === player.name).length;

                let nameHtml = `<span>üë§ ${player.name}`;
                if (player.name === playerName) {
                    nameHtml += ` <span class="you-badge">TU</span>`;
                }
                nameHtml += `</span>`;

                let rightSideHtml = '';
                if (voteCount > 0) {
                    rightSideHtml += `<span class="vote-count">${voteCount}</span>`;
                }

                button.innerHTML = nameHtml + rightSideHtml;

                if (myVote === player.name) {
                    button.classList.add('voted');
                }

                button.disabled = myVote !== null || amIEliminated;
                button.onclick = () => confirmVote(player.name);

                buttonWrapper.appendChild(button);
                buttonContainer.appendChild(buttonWrapper);
            });

            updateWaitingStatus();
        }

        function updateWaitingStatus() {
            const waitingStatus = document.getElementById('waitingStatus');
            const votedCount = Object.keys(votes).length;

            if (amIEliminated) {
                // Managed in showEliminatedState
            } else if (myVote) {
                waitingStatus.innerHTML = `<div class="waiting-animation">üó≥Ô∏è Hai votato! In attesa degli altri... (${votedCount}/${activePlayers.length})</div>`;
            } else {
                waitingStatus.innerHTML = '';
            }
        }

        async function confirmVote(votedFor) {
            if (myVote || amIEliminated) return;

            document.getElementById('confirmVoteName').textContent = votedFor;
            document.getElementById('confirmVoteModal').style.display = 'flex';

            document.getElementById('confirmVoteBtn').onclick = () => {
                closeConfirmModal();
                castVote(votedFor);
            };
        }

        async function castVote(votedFor) {
            if (myVote || amIEliminated) return;

            myVote = votedFor;
            votes[playerName] = votedFor; // Optimistic update

            // Update UI senza ricreare tutti i bottoni (evita animazione)
            document.querySelectorAll('.rounded-button').forEach(btn => {
                btn.disabled = true;

                // Trova il bottone del giocatore votato e aggiorna il counter
                if (btn.textContent.includes(votedFor)) {
                    btn.classList.add('voted');

                    // Aggiorna o aggiungi il badge del conteggio voti
                    const newVoteCount = Object.values(votes).filter(v => v === votedFor).length;
                    let voteCountSpan = btn.querySelector('.vote-count');
                    if (voteCountSpan) {
                        voteCountSpan.textContent = newVoteCount;
                    } else {
                        voteCountSpan = document.createElement('span');
                        voteCountSpan.className = 'vote-count';
                        voteCountSpan.textContent = newVoteCount;
                        btn.appendChild(voteCountSpan);
                    }
                }
            });
            updateWaitingStatus();

            await supabaseClient
                .from('players')
                .update({ vote_target: votedFor })
                .eq('id', myPlayer.id);

            // La subscription si occuper√† di aggiornare l'UI quando arrivano gli altri voti
        }

        async function checkAllVoted(cachedPlayers = null) {
            let currentPlayers = cachedPlayers;

            if (!currentPlayers) {
                // Ricarica stato voti solo se non passati
                const { data: fetched } = await supabaseClient
                    .from('players')
                    .select('*')
                    .eq('room_id', roomId);
                currentPlayers = fetched;
            }

            const eliminatedPlayers = currentRoom.eliminated_players || [];
            const active = currentPlayers.filter(p => !eliminatedPlayers.includes(p.name));

            // Ricostruisci mappa voti (SOLO dai giocatori attivi)
            const freshVotes = {};
            active.forEach(p => {
                if (p.vote_target) freshVotes[p.name] = p.vote_target;
            });

            // OPTIMIZATION: Evita re-render se i voti sono identici (es. chiamata da castVote o initVoting)
            // Usiamo JSON stringify per comparazione veloce di oggetti semplici
            const votesChanged = JSON.stringify(freshVotes) !== JSON.stringify(votes);

            votes = freshVotes;

            if (votesChanged) {
                renderButtons(); // Aggiorna UI solo se cambiato qualcosa
            }

            const votedCount = active.filter(p => p.vote_target).length;

            if (votedCount >= active.length && active.length > 0) {
                const sortedVoters = Object.keys(freshVotes).sort();
                const firstVoter = sortedVoters[0];
                const amIFirstVoter = firstVoter === playerName;

                console.log(`CheckAllVoted: ${votedCount}/${active.length} - FirstVoter: ${firstVoter}, Me: ${playerName} -> AmILeader? ${amIFirstVoter}`);

                if (!amIFirstVoter) return;

                const voteCounts = {};
                Object.values(freshVotes).forEach(v => {
                    voteCounts[v] = (voteCounts[v] || 0) + 1;
                });

                const maxVotes = Math.max(...Object.values(voteCounts));
                const playersWithMaxVotes = Object.entries(voteCounts)
                    .filter(([name, count]) => count === maxVotes)
                    .map(([name]) => name);

                console.log("Leader attempting update...", playersWithMaxVotes);

                if (playersWithMaxVotes.length > 1) {
                    const { data, error } = await supabaseClient
                        .from('rooms')
                        .update({
                            status: 'playing',
                            current_question: null,
                            last_eliminated: null
                        })
                        .eq('id', roomId)
                        .eq('status', 'voting')
                        .select();

                    if (error) console.error("Update error (tie):", error);
                    else console.log("Update success (tie):", data);

                    return;
                }

                const eliminated = playersWithMaxVotes[0];
                const eliminatedPlayer = allPlayers.find(p => p.name === eliminated);

                if (eliminatedPlayer && eliminatedPlayer.is_faker) {
                    await supabaseClient
                        .from('rooms')
                        .update({ status: 'finished', winner: 'players', faker_name: eliminated })
                        .eq('id', roomId);
                } else {
                    const currentEliminated = currentRoom.eliminated_players || [];
                    currentEliminated.push(eliminated);

                    const remainingPlayers = activePlayers.length - 1;

                    if (remainingPlayers <= 2) {
                        const faker = allPlayers.find(p => p.is_faker);
                        await supabaseClient
                            .from('rooms')
                            .update({
                                status: 'finished',
                                winner: 'faker',
                                faker_name: faker ? faker.name : '',
                                last_eliminated: eliminated,
                                eliminated_players: currentEliminated
                            })
                            .eq('id', roomId);
                    } else {
                        const { data, error } = await supabaseClient
                            .from('rooms')
                            .update({
                                status: 'playing',
                                current_question: null,
                                last_eliminated: eliminated,
                                eliminated_players: currentEliminated
                            })
                            .eq('id', roomId)
                            .eq('status', 'voting')
                            .select();

                        if (error) console.error("Update error (elimination):", error);
                        else console.log("Update success (elimination):", data);
                    }
                }
            }
        }

        function subscribeToVotes() {
            supabaseClient
                .channel('votes-channel-' + roomId + '-' + Date.now())
                .on('postgres_changes',
                    { event: 'UPDATE', schema: 'public', table: 'players', filter: `room_id=eq.${roomId}` },
                    (payload) => {
                        checkAllVoted(); // Ricarica e controlla
                    }
                )
                .on('postgres_changes',
                    { event: 'UPDATE', schema: 'public', table: 'rooms', filter: `id=eq.${roomId}` },
                    async (payload) => {
                        currentRoom = payload.new;
                        // Nota: i voti non sono pi√π in rooms.votes, ma in players table

                        const eliminatedPlayers = currentRoom.eliminated_players || [];
                        activePlayers = allPlayers.filter(p => !eliminatedPlayers.includes(p.name));

                        if (currentRoom.status === 'finished') {
                            if (currentRoom.winner === 'players') {
                                sessionStorage.setItem('gameResult', 'players_win');
                            } else {
                                sessionStorage.setItem('gameResult', 'faker_wins');
                            }
                            sessionStorage.setItem('faker_name', currentRoom.faker_name || '');
                            window.location.href = 'online_end.html';
                        } else if (currentRoom.status === 'playing') {
                            const eliminated = currentRoom.last_eliminated;
                            sessionStorage.removeItem('onlineDomanda');
                            pendingRedirect = 'online_game1.html';

                            if (eliminated) {
                                showResultModal('üòµ', 'Eliminato!', eliminated + ' era innocente ed √® stato eliminato.');
                            } else {
                                showResultModal('‚öñÔ∏è', 'Pareggio!', 'Nessuno √® stato eliminato. Si va al prossimo round!');
                            }
                        } else {
                            renderButtons();
                            checkAllVoted();
                        }
                    }
                )
                .subscribe();
        }

        initVoting();
    </script>
</body>

</html>